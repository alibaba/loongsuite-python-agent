#!/usr/bin/env python3

# Copyright The OpenTelemetry Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Generate bootstrap_gen.py for loongsuite-distro.

This script generates the libraries and default_instrumentations lists
used by loongsuite-bootstrap to install instrumentations.

Package naming and version strategy:
- instrumentation-genai/* packages: renamed to loongsuite-* prefix
- instrumentation-loongsuite/* packages: keep loongsuite-* prefix
- instrumentation/* packages: keep opentelemetry-* prefix (from upstream PyPI)

Version strategy:
- --upstream-version: Version for upstream opentelemetry-instrumentation-* packages
- --loongsuite-version: Version for loongsuite-* packages

Usage:
  # Generate with default versions from source
  python scripts/loongsuite/generate_loongsuite_bootstrap.py

  # Generate with specific versions for release
  python scripts/loongsuite/generate_loongsuite_bootstrap.py \\
    --upstream-version 0.60b1 \\
    --loongsuite-version 0.1.0
"""

import argparse
import ast
import logging
import subprocess
from pathlib import Path
from typing import Optional

import sys

import tomli

# Allow importing sibling modules from the parent scripts/ directory
sys.path.insert(0, str(Path(__file__).resolve().parent.parent))
from generate_instrumentation_bootstrap import (
    independent_packages,
    packages_to_exclude,
)
from otel_packaging import (
    get_instrumentation_packages as get_upstream_packages,
)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("loongsuite_bootstrap_generator")

scripts_path = Path(__file__).parent
root_path = scripts_path.parent.parent

_template = """
{header}

# DO NOT EDIT. THIS FILE WAS AUTOGENERATED FROM INSTRUMENTATION PACKAGES.
# RUN `python scripts/loongsuite/generate_loongsuite_bootstrap.py` TO REGENERATE.
#
# Generated with options:
#   --upstream-version: {upstream_version}
#   --loongsuite-version: {loongsuite_version}

{source}
"""

gen_path = (
    root_path
    / "loongsuite-distro"
    / "src"
    / "loongsuite"
    / "distro"
    / "bootstrap_gen.py"
)


def get_genai_packages_to_rename() -> dict[str, str]:
    """
    Dynamically discover instrumentation-genai packages that need renaming.

    Rule: All packages under instrumentation-genai/ with opentelemetry-* prefix
    should be renamed to loongsuite-* prefix, except those in packages_to_exclude.

    Returns:
        Dict mapping original name to new name, e.g.:
        {"opentelemetry-instrumentation-vertexai": "loongsuite-instrumentation-vertexai"}
    """
    result = {}
    genai_dir = root_path / "instrumentation-genai"

    if not genai_dir.exists():
        return result

    for pkg_dir in genai_dir.iterdir():
        if not pkg_dir.is_dir():
            continue

        pkg_name = pkg_dir.name

        # Rule: opentelemetry-* prefix packages should be renamed to loongsuite-*
        if pkg_name.startswith("opentelemetry-"):
            # Skip packages in upstream exclude list
            if pkg_name in packages_to_exclude:
                continue

            new_name = pkg_name.replace("opentelemetry-", "loongsuite-")
            result[pkg_name] = new_name

    return result


def get_instrumentation_packages(
    upstream_version: Optional[str] = None,
    loongsuite_version: Optional[str] = None,
):
    """
    Get all instrumentation packages from various directories.

    Args:
        upstream_version: Override version for upstream opentelemetry-* packages
        loongsuite_version: Override version for loongsuite-* packages

    Note:
        When the same package name exists in both instrumentation-genai and
        instrumentation-loongsuite, the version from instrumentation-loongsuite
        takes precedence (overwrites the earlier one).
    """
    packages = []
    seen_packages: dict[str, int] = {}  # name -> index in packages list

    logger.info("Scanning instrumentation packages...")

    # Dynamically get packages that need renaming
    genai_packages_to_rename = get_genai_packages_to_rename()

    # Get packages from upstream directories (instrumentation, instrumentation-genai)
    logger.info(
        "Processing upstream packages (instrumentation, instrumentation-genai)..."
    )
    for pkg in get_upstream_packages(
        independent_packages=independent_packages
    ):
        pkg_name = pkg["name"]

        # Skip packages in exclude list (follow upstream behavior)
        if pkg_name in packages_to_exclude:
            continue

        # Check if this package should be renamed (instrumentation-genai with opentelemetry-* prefix)
        if pkg_name in genai_packages_to_rename:
            new_name = genai_packages_to_rename[pkg_name]
            logger.info(f"Renaming {pkg_name} -> {new_name}")
            pkg["name"] = new_name

            # Use loongsuite version for renamed packages
            if loongsuite_version:
                pkg["requirement"] = f"{new_name}=={loongsuite_version}"
            else:
                # Keep original version but update name
                pkg["requirement"] = pkg["requirement"].replace(
                    pkg_name, new_name
                )
        else:
            # Use upstream version for opentelemetry-* packages
            if upstream_version and pkg_name.startswith("opentelemetry-"):
                pkg["requirement"] = f"{pkg_name}=={upstream_version}"

        # Track package by name (for deduplication)
        final_name = pkg["name"]
        if final_name in seen_packages:
            # Replace existing package (instrumentation-loongsuite should win)
            idx = seen_packages[final_name]
            packages[idx] = pkg
        else:
            seen_packages[final_name] = len(packages)
            packages.append(pkg)

    # Scan instrumentation-loongsuite directory
    loongsuite_dir = root_path / "instrumentation-loongsuite"
    if loongsuite_dir.exists():
        logger.info(
            "Processing loongsuite packages (instrumentation-loongsuite)..."
        )
        pkg_dirs = sorted([d for d in loongsuite_dir.iterdir() if d.is_dir()])
        for pkg_dir in pkg_dirs:
            pyproject_toml = pkg_dir / "pyproject.toml"
            if not pyproject_toml.exists():
                continue

            try:
                # Get version using hatch command
                version = subprocess.check_output(
                    "hatch version",
                    shell=True,
                    cwd=pkg_dir,
                    universal_newlines=True,
                    stderr=subprocess.DEVNULL,
                ).strip()

                # Read pyproject.toml
                with open(pyproject_toml, "rb") as f:
                    pyproject = tomli.load(f)

                pkg_name = pyproject["project"]["name"]

                if pkg_name in packages_to_exclude:
                    continue

                # Get optional dependencies
                optional_deps = pyproject["project"].get(
                    "optional-dependencies", {}
                )
                instruments = optional_deps.get("instruments", [])
                instruments_any = optional_deps.get("instruments-any", [])

                # Use loongsuite version if specified
                if loongsuite_version:
                    requirement = f"{pkg_name}=={loongsuite_version}"
                elif pkg_name in independent_packages:
                    specifier = independent_packages[pkg_name]
                    requirement = (
                        f"{pkg_name}{specifier}"
                        if specifier
                        else f"{pkg_name}=={version}"
                    )
                else:
                    requirement = f"{pkg_name}=={version}"

                new_pkg = {
                    "name": pkg_name,
                    "version": version,
                    "instruments": instruments,
                    "instruments-any": instruments_any,
                    "requirement": requirement,
                }

                # Deduplication: instrumentation-loongsuite takes precedence
                if pkg_name in seen_packages:
                    idx = seen_packages[pkg_name]
                    logger.info(
                        f"Overwriting {pkg_name} with instrumentation-loongsuite version"
                    )
                    packages[idx] = new_pkg
                else:
                    seen_packages[pkg_name] = len(packages)
                    packages.append(new_pkg)
            except subprocess.CalledProcessError as e:
                logger.warning(
                    f"Could not get hatch version from {pkg_dir.name}: {e}"
                )
                continue
            except Exception as e:
                logger.warning(f"Failed to process {pkg_dir.name}: {e}")
                continue

    return packages


def main():
    parser = argparse.ArgumentParser(
        description="Generate bootstrap_gen.py for loongsuite-distro"
    )
    parser.add_argument(
        "--upstream-version",
        type=str,
        default=None,
        help="Override version for upstream opentelemetry-instrumentation-* packages (e.g., 0.60b1)",
    )
    parser.add_argument(
        "--loongsuite-version",
        type=str,
        default=None,
        help="Override version for loongsuite-* packages (e.g., 0.1.0)",
    )
    args = parser.parse_args()

    # Read license header
    header_path = scripts_path.parent / "license_header.txt"
    if header_path.exists():
        with open(header_path, "r", encoding="utf-8") as f:
            header = f.read()
    else:
        header = "# Copyright The OpenTelemetry Authors\n# Licensed under the Apache License, Version 2.0\n"

    # Get all packages
    packages = get_instrumentation_packages(
        upstream_version=args.upstream_version,
        loongsuite_version=args.loongsuite_version,
    )
    logger.info(f"Found {len(packages)} instrumentation packages")

    # Build AST nodes
    default_instrumentations = ast.List(elts=[])
    libraries = ast.List(elts=[])

    logger.info("Building bootstrap configuration...")
    for pkg in packages:
        # If no instruments and no instruments-any, it's a default instrumentation
        if not pkg.get("instruments") and not pkg.get("instruments-any"):
            default_instrumentations.elts.append(
                ast.Constant(value=pkg["requirement"])
            )
        else:
            # Add instruments (all must be installed)
            for target_pkg in pkg.get("instruments", []):
                libraries.elts.append(
                    ast.Dict(
                        keys=[
                            ast.Constant(value="library"),
                            ast.Constant(value="instrumentation"),
                        ],
                        values=[
                            ast.Constant(value=target_pkg),
                            ast.Constant(value=pkg["requirement"]),
                        ],
                    )
                )

            # Add instruments-any (at least one must be installed)
            for target_pkg in pkg.get("instruments-any", []):
                libraries.elts.append(
                    ast.Dict(
                        keys=[
                            ast.Constant(value="library"),
                            ast.Constant(value="instrumentation"),
                        ],
                        values=[
                            ast.Constant(value=target_pkg),
                            ast.Constant(value=pkg["requirement"]),
                        ],
                    )
                )

    # Generate source code
    logger.info("Generating source code...")
    # Build libraries list string
    libraries_lines = ["libraries = ["]
    for lib_mapping in libraries.elts:
        if isinstance(lib_mapping, ast.Dict):
            lib_key = lib_mapping.keys[0]
            instr_key = lib_mapping.keys[1]
            lib_val_node = lib_mapping.values[0]
            instr_val_node = lib_mapping.values[1]

            lib_key_str = (
                lib_key.value
                if isinstance(lib_key, ast.Constant)
                else (lib_key.s if hasattr(lib_key, "s") else "library")
            )
            instr_key_str = (
                instr_key.value
                if isinstance(instr_key, ast.Constant)
                else (
                    instr_key.s
                    if hasattr(instr_key, "s")
                    else "instrumentation"
                )
            )
            lib_val_str = (
                lib_val_node.value
                if isinstance(lib_val_node, ast.Constant)
                else (lib_val_node.s if hasattr(lib_val_node, "s") else "")
            )
            instr_val_str = (
                instr_val_node.value
                if isinstance(instr_val_node, ast.Constant)
                else (instr_val_node.s if hasattr(instr_val_node, "s") else "")
            )

            lib_val_str = lib_val_str.replace('"', '\\"')
            instr_val_str = instr_val_str.replace('"', '\\"')

            libraries_lines.append(
                f'    {{"{lib_key_str}": "{lib_val_str}", "{instr_key_str}": "{instr_val_str}"}},'
            )
    libraries_lines.append("]")

    # Build default_instrumentations list string
    default_lines = ["default_instrumentations = ["]
    for default_instr in default_instrumentations.elts:
        if isinstance(default_instr, ast.Constant):
            instr_val = default_instr.value.replace('"', '\\"')
            default_lines.append(f'    "{instr_val}",')
    default_lines.append("]")

    # Combine source
    source = "\n".join(libraries_lines) + "\n\n" + "\n".join(default_lines)

    # Format with header and version info
    formatted_source = _template.format(
        header=header,
        source=source,
        upstream_version=args.upstream_version or "(from source)",
        loongsuite_version=args.loongsuite_version or "(from source)",
    )

    # Write to file
    gen_path.parent.mkdir(parents=True, exist_ok=True)
    with open(gen_path, "w", encoding="utf-8") as f:
        f.write(formatted_source)

    logger.info("generated %s", gen_path)
    logger.info(
        "  - %d default instrumentations", len(default_instrumentations.elts)
    )
    logger.info("  - %d library mappings", len(libraries.elts))


if __name__ == "__main__":
    main()
