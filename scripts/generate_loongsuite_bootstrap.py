#!/usr/bin/env python3

# Copyright The OpenTelemetry Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import ast
import logging
import subprocess
from pathlib import Path

import tomli
from generate_instrumentation_bootstrap import (
    independent_packages,
    packages_to_exclude,
)
from otel_packaging import get_instrumentation_packages as get_upstream_packages

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("loongsuite_bootstrap_generator")

# Get root path
scripts_path = Path(__file__).parent
root_path = scripts_path.parent

_template = """
{header}

# DO NOT EDIT. THIS FILE WAS AUTOGENERATED FROM INSTRUMENTATION PACKAGES.
# RUN `python scripts/generate_loongsuite_bootstrap.py` TO REGENERATE.

{source}
"""

_source_tmpl = """
libraries = []
default_instrumentations = []
"""

gen_path = root_path / "loongsuite-distro" / "src" / "loongsuite" / "distro" / "bootstrap_gen.py"


def get_instrumentation_packages():
    """Get all instrumentation packages from various directories"""
    packages = []
    
    logger.info("Scanning instrumentation packages...")
    
    # Get packages from upstream directories (instrumentation, instrumentation-genai)
    # using otel_packaging
    logger.info("Processing upstream packages (instrumentation, instrumentation-genai)...")
    for pkg in get_upstream_packages(independent_packages=independent_packages):
        if pkg["name"] not in packages_to_exclude:
            packages.append(pkg)
    
    # Scan instrumentation-loongsuite directory (reuse same logic as otel_packaging)
    loongsuite_dir = root_path / "instrumentation-loongsuite"
    if loongsuite_dir.exists():
        logger.info("Processing loongsuite packages (instrumentation-loongsuite)...")
        pkg_dirs = sorted([d for d in loongsuite_dir.iterdir() if d.is_dir()])
        for pkg_dir in pkg_dirs:
            pyproject_toml = pkg_dir / "pyproject.toml"
            if not pyproject_toml.exists():
                continue
            
            try:
                # Get version using hatch command (same as otel_packaging)
                # Suppress hatch's verbose output
                version = subprocess.check_output(
                    "hatch version",
                    shell=True,
                    cwd=pkg_dir,
                    universal_newlines=True,
                ).strip()
                
                # Read pyproject.toml
                with open(pyproject_toml, "rb") as f:
                    pyproject = tomli.load(f)
                
                pkg_name = pyproject["project"]["name"]
                
                # Skip if this package is in the exclusion list
                if pkg_name in packages_to_exclude:
                    continue
                
                # Get optional dependencies
                optional_deps = pyproject["project"]["optional-dependencies"]
                instruments = optional_deps.get("instruments", [])
                instruments_any = optional_deps.get("instruments-any", [])
                
                # Handle independent packages
                if pkg_name in independent_packages:
                    specifier = independent_packages[pkg_name]
                    requirement = f"{pkg_name}{specifier}" if specifier else f"{pkg_name}=={version}"
                else:
                    requirement = f"{pkg_name}=={version}"
                
                packages.append({
                    "name": pkg_name,
                    "version": version,
                    "instruments": instruments,
                    "instruments-any": instruments_any,
                    "requirement": requirement,
                })
            except subprocess.CalledProcessError as e:
                logger.warning(f"Could not get hatch version from {pkg_dir.name}: {e}")
                continue
            except Exception as e:
                logger.warning(f"Failed to process {pkg_dir.name}: {e}")
                continue
    
    return packages


def main():
    # Read license header
    header_path = scripts_path / "license_header.txt"
    if header_path.exists():
        with open(header_path, "r", encoding="utf-8") as f:
            header = f.read()
    else:
        header = "# Copyright The OpenTelemetry Authors\n# Licensed under the Apache License, Version 2.0\n"
    
    # Get all packages
    packages = get_instrumentation_packages()
    logger.info(f"Found {len(packages)} instrumentation packages")
    
    # Build AST nodes
    default_instrumentations = ast.List(elts=[])
    libraries = ast.List(elts=[])
    
    logger.info("Building bootstrap configuration...")
    for pkg in packages:
        # If no instruments and no instruments-any, it's a default instrumentation
        if not pkg["instruments"] and not pkg["instruments-any"]:
            default_instrumentations.elts.append(
                ast.Constant(value=pkg["requirement"])
            )
        else:
            # Add instruments (all must be installed)
            for target_pkg in pkg["instruments"]:
                libraries.elts.append(
                    ast.Dict(
                        keys=[
                            ast.Constant(value="library"),
                            ast.Constant(value="instrumentation"),
                        ],
                        values=[
                            ast.Constant(value=target_pkg),
                            ast.Constant(value=pkg["requirement"]),
                        ],
                    )
                )
            
            # Add instruments-any (at least one must be installed)
            for target_pkg in pkg["instruments-any"]:
                libraries.elts.append(
                    ast.Dict(
                        keys=[
                            ast.Constant(value="library"),
                            ast.Constant(value="instrumentation"),
                        ],
                        values=[
                            ast.Constant(value=target_pkg),
                            ast.Constant(value=pkg["requirement"]),
                        ],
                    )
                )
    
    # Generate source code manually (avoiding astor dependency)
    logger.info("Generating source code...")
    # Build libraries list string
    libraries_lines = ["libraries = ["]
    for lib_mapping in libraries.elts:
        if isinstance(lib_mapping, ast.Dict):
            # Extract keys and values
            lib_key = lib_mapping.keys[0]
            instr_key = lib_mapping.keys[1]
            lib_val_node = lib_mapping.values[0]
            instr_val_node = lib_mapping.values[1]
            
            # Get string values
            lib_key_str = lib_key.value if isinstance(lib_key, ast.Constant) else (lib_key.s if hasattr(lib_key, 's') else "library")
            instr_key_str = instr_key.value if isinstance(instr_key, ast.Constant) else (instr_key.s if hasattr(instr_key, 's') else "instrumentation")
            lib_val_str = lib_val_node.value if isinstance(lib_val_node, ast.Constant) else (lib_val_node.s if hasattr(lib_val_node, 's') else "")
            instr_val_str = instr_val_node.value if isinstance(instr_val_node, ast.Constant) else (instr_val_node.s if hasattr(instr_val_node, 's') else "")
            
            # Escape quotes in values
            lib_val_str = lib_val_str.replace('"', '\\"')
            instr_val_str = instr_val_str.replace('"', '\\"')
            
            libraries_lines.append(f'    {{"{lib_key_str}": "{lib_val_str}", "{instr_key_str}": "{instr_val_str}"}},')
    libraries_lines.append("]")
    
    # Build default_instrumentations list string
    default_lines = ["default_instrumentations = ["]
    for default_instr in default_instrumentations.elts:
        if isinstance(default_instr, ast.Constant):
            instr_val = default_instr.value.replace('"', '\\"')
            default_lines.append(f'    "{instr_val}",')
    default_lines.append("]")
    
    # Combine source
    source = "\n".join(libraries_lines) + "\n\n" + "\n".join(default_lines)
    
    # Format with header
    formatted_source = _template.format(header=header, source=source)
    
    # Write to file
    gen_path.parent.mkdir(parents=True, exist_ok=True)
    with open(gen_path, "w", encoding="utf-8") as f:
        f.write(formatted_source)
    
    logger.info("generated %s", gen_path)
    logger.info("  - %d default instrumentations", len(default_instrumentations.elts))
    logger.info("  - %d library mappings", len(libraries.elts))


if __name__ == "__main__":
    main()

